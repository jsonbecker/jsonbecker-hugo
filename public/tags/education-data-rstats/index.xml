<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Education Data Rstats on JSONBecker</title>
    <link>http://www.jsonbecker.com/tags/education-data-rstats.html</link>
    <description>Recent content in Education Data Rstats on JSONBecker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Sep 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.jsonbecker.com/tags/education-data-rstats.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using R to Calculate Student Moblity</title>
      <link>http://www.jsonbecker.com/2013/09/using-r-to-calculate-student-moblity</link>
      <pubDate>Mon, 23 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://www.jsonbecker.com/2013/09/using-r-to-calculate-student-moblity</guid>
      <description>

&lt;p&gt;In a couple of previous posts, I outlined the importance of &lt;a href=&#34;filename|documentation-of-business-rules-and-analysis.md&#34;&gt;documenting business rules for common education statistics&lt;/a&gt; and described my take on how to &lt;a href=&#34;new-calculation-for-student-mobility.md&#34;&gt;best calculate student mobility&lt;/a&gt;. In this post, I will be sharing two versions of R function I wrote to implement this mobility calculation, reviewing their different structure and methods to reveal how I achieved an order of magnitude speed up between the two versions. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:optimization&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:optimization&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; At the end of this post, I will propose several future routes for optimization that I believe should lead to the ability to handle millions of student records in seconds.&lt;/p&gt;

&lt;h2 id=&#34;version-0-where-do-i-begin&#34;&gt;Version 0: Where Do I Begin?&lt;/h2&gt;

&lt;p&gt;The first thing I tend to do is whiteboard the rules I want to use through careful consideration and constant referal back to real data sets. By staying grounded in the data, I am less likely to encounter unexpected situations during my quality control. It also makes it much easier to develop test data, since I seek out outlier records in actual data during the business rule process.&lt;/p&gt;

&lt;p&gt;Developing test data is a key part of the development process. Without a compact, but sufficiently complex, set of data to try with a newly developed function, there is no way to know whether or not it does what I intend.&lt;/p&gt;

&lt;p&gt;Recall the &lt;a href=&#34;filename|new-calculation-for-student-mobility.md&#34;&gt;business rules for mobility&lt;/a&gt; that I have proposed, all of which came out of this whiteboarding process:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Entering the data with an enroll date after the start of the year counts as one move.&lt;/li&gt;
&lt;li&gt;Leaving the data with an exit date before the end of the year counts as one move.&lt;/li&gt;
&lt;li&gt;Changing schools sometime during the year without a large gap in enrollment counts as one move.&lt;/li&gt;
&lt;li&gt;Changing schools sometime during the year with a large gap in enrollment counts as two moves.&lt;/li&gt;
&lt;li&gt;Adjacent enrollment records for the same student in the same school without a large gap in enrollment does not count as moving.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Test data needs to represent each of these situations so that I can confirm the function is properly implementing each rule.&lt;/p&gt;

&lt;p&gt;Below is a copy of my test data. As an exercise, I recommend determining the number of &amp;ldquo;moves&amp;rdquo; each of these students should be credited with after applying the above stated business rules.&lt;/p&gt;

&lt;p&gt;| Unique Student ID   | School Code   | Enrollment Date   | Exit Date    |  |
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; |  |
| 1000000             | 10101         | 2012-10-15        | 2012-11-15   |  |
| 1000000             | 10103         | 2012-01-03        | 2013-03-13   |  |
| 1000000             | 10103         | 2012-03-20        | 2013-05-13   |  |
| 1000001             | 10101         | 2012-09-01        | 2013-06-15   |  |
| 1000002             | 10102         | 2012-09-01        | 2013-01-23   |  |
| 1000003             | 10102         | 2012-09-15        | 2012-11-15   |  |
| 1000003             | 10102         | 2013-03-15        | 2013-06-15   |  |
| 1000004             | 10103         | 2013-03-15        | NA           |  |&lt;/p&gt;

&lt;h2 id=&#34;version-1-a-na誰ve-implementation&#34;&gt;Version 1: A Na誰ve Implementation&lt;/h2&gt;

&lt;p&gt;Once I have developed business rules and a test data set, I like to quickly confirm that I can produce the desired results. That&amp;rsquo;s particularly true when it comes to implementing a new, fairly complex business rules. My initial implementation of a new algorithm does not need to be efficient, easily understood, or maintainable. My goal is simply to follow my initial hunch on how to accomplish a task and get it working. Sometimes this &lt;em&gt;na誰ve implementation&lt;/em&gt; turns out to be pretty close to my final implementation, but sometimes it can be quite far off. The main things I tend to improve with additional work are extensibility, readability, and performance.&lt;/p&gt;

&lt;p&gt;In the case of this mobility calculation, I knew almost immediately that my initial approach was not going to have good performance characteristics. Here is a step by step discussion of Version 1.&lt;/p&gt;

&lt;h3 id=&#34;function-declaration-parameters&#34;&gt;Function Declaration: Parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;moves_calc &amp;lt;- function(df, 
                       enrollby,
                       exitby,
                       gap=14,
                       sid=&#39;sid&#39;, 
                       schid=&#39;schid&#39;,
                       enroll_date=&#39;enroll_date&#39;,
                       exit_date=&#39;exit_date&#39;)){
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I named my function &lt;code&gt;moves_calc()&lt;/code&gt; to match the style of &lt;code&gt;age_calc()&lt;/code&gt; which was submitted and accepted to the eeptools package. This new function has eight parameters.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df&lt;/code&gt;: a &lt;code&gt;data.frame&lt;/code&gt; containing the required data to do the mobility calculation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enrollby&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; or &lt;code&gt;Date&lt;/code&gt; in the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This parameter signifies the start of the school year. Students whose first enrollment is after this date will have an additional  &lt;code&gt;move&lt;/code&gt; under the assumption that they enrolled somewhere prior to the first enrollment record in the data. This does not (and likely should not) match the actual first day of the school year.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exitby&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; or &lt;code&gt;Date&lt;/code&gt; in the format  &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This parameter signifies the end of the school year. Students whose last exit is before this date will have an additional &lt;code&gt;move&lt;/code&gt; under the assumption that they enrolled somewhere after this exit record that is excluded in the data. This date does not (and likely should not) match the actual last day of the school year.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gap&lt;/code&gt;: an atomic vector of type &lt;code&gt;numeric&lt;/code&gt; that signifies how long a gap must exist between student records to record an additional move for that student under the assumption that they enrolled somewhere in between the two records in the data that is not recorded.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sid&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; that represents the name of the vector in &lt;code&gt;df&lt;/code&gt; that contains the unique student identifier. The default value is &lt;code&gt;&#39;sid&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;schid&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; that represents the name of the vector in &lt;code&gt;df&lt;/code&gt; that contains the unique school identifier. The default value is &lt;code&gt;schid&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enroll_date&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; that represents the name of the vector in &lt;code&gt;df&lt;/code&gt; that contains the enrollment date for each record. The default value is &lt;code&gt;enroll_date&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exit_date&lt;/code&gt;: an atomic vector of type &lt;code&gt;character&lt;/code&gt; that represents the name of the vector in &lt;code&gt;df&lt;/code&gt; that contains the exit date for each record. The default value is &lt;code&gt;exit_date&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most of these parameters are about providing flexibility around the naming of attributes in the data set. Although I often write functions for my own work which accept &lt;code&gt;data.frames&lt;/code&gt;, I can not help but to feel this is a bad practice. Assuming particular data attributes of the right name and type does not make for generalizable code. To make up for my shortcoming in this area, I have done my best to allow other users to enter whatever data column names they want, so long as they contain the right information to run the algorithm.&lt;/p&gt;

&lt;p&gt;The next portion of the function loads some of the required packages and is common to many of my custom functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(&amp;quot;data.table&amp;quot; %in% rownames(installed.packages()) == FALSE){
    install.packages(&amp;quot;data.table&amp;quot;)
  } 
require(data.table)

if(&amp;quot;plyr&amp;quot; %in% rownames(installed.packages()) == FALSE){
    install.packages(&amp;quot;plyr&amp;quot;)
  } 
require(plyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;type-checking-and-programmatic-defaults&#34;&gt;Type Checking and Programmatic Defaults&lt;/h3&gt;

&lt;p&gt;Next, I do extensive type-checking to make sure that &lt;code&gt;df&lt;/code&gt; is structured the way I expect it to be in order to run the algorithm. I do my best to supply humane &lt;code&gt;warning()&lt;/code&gt; and &lt;code&gt;stop()&lt;/code&gt; messages when things go wrong, and in some cases, set default values that may help the function run even if function is not called properly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (!inherits(df[[enroll_date]], &amp;quot;Date&amp;quot;) | !inherits(df[[exit_date]], &amp;quot;Date&amp;quot;))
    stop(&amp;quot;Both enroll_date and exit_date must be Date objects&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;enroll_date&lt;/code&gt; and &lt;code&gt;exit_date&lt;/code&gt; both have to be &lt;code&gt;Date&lt;/code&gt; objects. I could have attempted to coerce those vectors into &lt;code&gt;Date&lt;/code&gt; types using &lt;code&gt;as.Date()&lt;/code&gt;, but I would rather not assume something like the date format. Since &lt;code&gt;enroll_date&lt;/code&gt; and &lt;code&gt;exit_date&lt;/code&gt; are the most critical attributes of each student, the function will &lt;code&gt;stop()&lt;/code&gt; if they are the incorrect type, informing the analyst to clean up the data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(missing(enrollby)){
   enrollby &amp;lt;- as.Date(paste(year(min(df$enroll_date, na.rm=TRUE)),
                              &#39;-09-15&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
}else{
  if(is.na(as.Date(enrollby, format=&amp;quot;%Y-%m-%d&amp;quot;))){
     enrollby &amp;lt;- as.Date(paste(year(min(df$enroll_date, na.rm=TRUE)),
                               &#39;-09-15&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;
     warning(paste(&amp;quot;enrollby must be a string with format %Y-%m-%d,&amp;quot;,
                   &amp;quot;defaulting to&amp;quot;, 
                   enrollby, sep=&#39; &#39;))
  }else{
    enrollby &amp;lt;- as.Date(enrollby, format=&amp;quot;%Y-%m-%d&amp;quot;)
  }
}
if(missing(exitby)){
  exitby &amp;lt;- as.Date(paste(year(max(df$exit_date, na.rm=TRUE)),
                          &#39;-06-01&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
}else{
  if(is.na(as.Date(exitby, format=&amp;quot;%Y-%m-%d&amp;quot;))){
    exitby &amp;lt;- as.Date(paste(year(max(df$exit_date, na.rm=TRUE)),
                              &#39;-06-01&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
    warning(paste(&amp;quot;exitby must be a string with format %Y-%m-%d,&amp;quot;,
                  &amp;quot;defaulting to&amp;quot;, 
                  exitby, sep=&#39; &#39;))
  }else{
    exitby &amp;lt;- as.Date(exitby, format=&amp;quot;%Y-%m-%d&amp;quot;)
  }
}
if(!is.numeric(gap)){
  gap &amp;lt;- 14
  warning(&amp;quot;gap was not a number, defaulting to 14 days&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For maximum flexibility, I have parameterized the &lt;code&gt;enrollby&lt;/code&gt;, &lt;code&gt;exitby&lt;/code&gt;, and &lt;code&gt;gap&lt;/code&gt; used by the algorithm to determine student moves. An astute observer of the function declaration may have noticed I did not set default values for &lt;code&gt;enrollby&lt;/code&gt; or &lt;code&gt;exitby&lt;/code&gt;. This is because these dates are naturally going to be different which each year of data. As a result, I want to enforce their explicit declaration.&lt;/p&gt;

&lt;p&gt;However, we all make mistakes. So when I check to see if &lt;code&gt;enrollby&lt;/code&gt; or &lt;code&gt;exitby&lt;/code&gt; are &lt;code&gt;missing()&lt;/code&gt;, I do not stop the function if it returns &lt;code&gt;TRUE&lt;/code&gt;. Instead, I set the value &lt;code&gt;enrollby&lt;/code&gt; to September 15 in the year that matches the minimum (first) enrollment record and &lt;code&gt;exitby&lt;/code&gt; to June 1 in the year that matches the maximum (last) exit record. I then pop off a &lt;code&gt;warning()&lt;/code&gt; that informs the user the expected values for each parameter and what values I have defaulted them to. I chose to use &lt;code&gt;warning()&lt;/code&gt; because many R users set their environment to halt at &lt;code&gt;warnings()&lt;/code&gt;. They are generally not good and should be pursued and fixed. No one should depend upon the defaulting process I use in the function. But the defaults that can be determined programmatically are sensible enough that I did not feel the need to always halt the function in its place.&lt;/p&gt;

&lt;p&gt;I also check to see if &lt;code&gt;gap&lt;/code&gt; is, in fact, defined as a number. If not, I also throw a &lt;code&gt;warning()&lt;/code&gt; after setting &lt;code&gt;gap&lt;/code&gt; equal to default value of &lt;code&gt;14&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Is this all of the type and error-checking I could have included? Probably not, but I think this represents a very sensible set that make this function much more generalizable outside of my coding environment. This kind of checking may be overkill for a project that is worked on independently and with a single data set, but colleagues, including your future self, will likely be thankful for their inclusion if any of your code is to be reused.&lt;/p&gt;

&lt;h3 id=&#34;initializing-the-results&#34;&gt;Initializing the Results&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;output &amp;lt;- data.frame(id = as.character(unique(df[[sid]])),
                     moves = vector(mode = &#39;numeric&#39;, 
                                    length = length(unique(df[[sid]]))))
output &amp;lt;- data.table(output, key=&#39;id&#39;)
df &amp;lt;- arrange(df, sid, enroll_date)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My na誰ve implementation uses a lot of &lt;code&gt;for&lt;/code&gt; loops, a no-no when it comes to R performance. One way to make &lt;code&gt;for&lt;/code&gt; loops a lot worse, and this is true in any language, is to reassign a variable within the loop. This means that each iteration has the overhead of creating and assigning that object. Especially when we are building up results for each observation, it is silly to do this. We know exactly how big the data will be and therefore only need to create the object once. We can then assign a much smaller part of that object (in this case, one value in a vector) rather than the whole object (a honking &lt;code&gt;data.table&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;output&lt;/code&gt; object is what the function returns. It is a simple &lt;code&gt;data.table&lt;/code&gt; containing all of the unique student identifiers and the number of &lt;code&gt;moves&lt;/code&gt; recorded for each student.&lt;/p&gt;

&lt;p&gt;The last line in this code chunk ensures that the data are arranged by the unique student identifier and enrollment date. This is key since the &lt;code&gt;for&lt;/code&gt; loops assume that they are traversing a student&amp;rsquo;s record sequentially.&lt;/p&gt;

&lt;h3 id=&#34;business-rule-1-the-latecomer&#34;&gt;Business Rule 1: The Latecomer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(i in 1:(length(df[[sid]])-1)){
  if(i&amp;gt;1 &amp;amp;&amp;amp; df[sid][i,]!=df[sid][(i-1),]){
    if(df[[&#39;enroll_date&#39;]][i]&amp;gt;enrollby){
      output[as.character(df[[sid]][i]), moves:=moves+1L]
    }
  }else if(i==1){
    if(df[[&#39;enroll_date&#39;]][i]&amp;gt;enrollby){
    output[as.character(df[[sid]][i]), moves:=moves+1L]
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first bit of logic checks if &lt;code&gt;sid&lt;/code&gt; in row &lt;code&gt;i&lt;/code&gt; is not equal to the &lt;code&gt;sid&lt;/code&gt; in the &lt;code&gt;i-1&lt;/code&gt; row. In other words, is this the first time we are observing this student? If it is, then row &lt;code&gt;i&lt;/code&gt; is the first observation for that student and therefore has the minimum enrollment date. The &lt;code&gt;enroll_date&lt;/code&gt; is checked against &lt;code&gt;enrollby&lt;/code&gt;. When &lt;code&gt;enroll_date&lt;/code&gt; is after &lt;code&gt;enrollby&lt;/code&gt;, then the &lt;code&gt;moves&lt;/code&gt; attribute for that &lt;code&gt;sid&lt;/code&gt; is incremented by 1. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:increments&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:increments&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Now, I didn&amp;rsquo;t really mention the conditional that &lt;code&gt;i&amp;gt;1&lt;/code&gt;. This is needed because there is no &lt;code&gt;i-1&lt;/code&gt; observation for the very first row of the &lt;code&gt;data.table&lt;/code&gt;. Therefore, &lt;code&gt;i==1&lt;/code&gt; is a special case where we once again perform the same check for &lt;code&gt;enroll_date&lt;/code&gt; and &lt;code&gt;enrollby&lt;/code&gt;. The &lt;code&gt;i&amp;gt;1&lt;/code&gt; condition is before the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which ensures the statement after the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is not evaluated when the first conditional is &lt;code&gt;FALSE&lt;/code&gt;. This avoids an &amp;ldquo;out of bounds&amp;rdquo;-type error where R tries to check &lt;code&gt;df[0]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;business-rule-5-the-feint&#34;&gt;Business Rule 5: The Feint&lt;/h3&gt;

&lt;p&gt;Yeah, yeah&amp;ndash; the business rule list above doesn&amp;rsquo;t match the order of my function. That&amp;rsquo;s ok. Remember, sometimes giving instructions to a computer does not follow the way you would organize instructions for humans.&lt;/p&gt;

&lt;p&gt;Remember, the function is traversing through our &lt;code&gt;data.frame&lt;/code&gt; one row at a time. First I checked to see if the function is at the first record for a particular student. Now I check to see if there are any records after the current record.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  if(df[sid][i,]==df[sid][(i+1),]){
    if(as.numeric(difftime(df[[&#39;enroll_date&#39;]][i+1], 
                           df[[&#39;exit_date&#39;]][i], units=&#39;days&#39;)) &amp;lt; gap &amp;amp;
       df[schid][(i+1),]==df[schid][i,]){
        next
    }else if ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the case where the &lt;code&gt;i+1&lt;/code&gt; record has the same &lt;code&gt;sid&lt;/code&gt;, then the &lt;code&gt;enroll_date&lt;/code&gt; of &lt;code&gt;i+1&lt;/code&gt; is subtracted from the &lt;code&gt;exit_date&lt;/code&gt; of &lt;code&gt;i&lt;/code&gt; and checked against &lt;code&gt;gap&lt;/code&gt;. If it is both less than &lt;code&gt;gap&lt;/code&gt; and the &lt;code&gt;schid&lt;/code&gt; of &lt;code&gt;i+1&lt;/code&gt; is the same as &lt;code&gt;i&lt;/code&gt;, then &lt;code&gt;next&lt;/code&gt;, which basically breaks out of this conditional and moves on without altering moves. In other words, students who are in the same school with only a few days between the time they exited are not counting has having moved.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;...&lt;/code&gt; above is not the special &lt;code&gt;...&lt;/code&gt; in R, rather, I&amp;rsquo;m continuing that line below.&lt;/p&gt;

&lt;h3 id=&#34;business-rule-3-the-smooth-mover&#34;&gt;Business Rule 3: The Smooth Mover&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  }else if(as.numeric(difftime(df[[&#39;enroll_date&#39;]][i+1], 
                               df[[&#39;exit_date&#39;]][i], 
                               units=&#39;days&#39;)) &amp;lt; gap){
    output[as.character(df[[sid]][i]), moves:=moves+1L] 
  }else{ ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have the simple case where a student has moved to another school (recall, this is still within the &lt;code&gt;if&lt;/code&gt; conditional where the next record is the same student as the current record) with a very short period of time between the &lt;code&gt;exit_date&lt;/code&gt; at the current record and the &lt;code&gt;enroll_date&lt;/code&gt; of the next record. This is considered a &amp;ldquo;seamless&amp;rdquo; move from one school to another, and therefore that student&amp;rsquo;s moves are incremented by 1.&lt;/p&gt;

&lt;h3 id=&#34;business-rule-4-the-long-hop&#34;&gt;Business Rule 4: The Long Hop&lt;/h3&gt;

&lt;p&gt;Our final scenario for a student moving between schools is when the gap between the &lt;code&gt;exit_date&lt;/code&gt; at the &lt;code&gt;i&lt;/code&gt; school and the &lt;code&gt;enroll_date&lt;/code&gt; at the &lt;code&gt;i+1&lt;/code&gt; school is large, defined as &lt;code&gt;&amp;gt; gap&lt;/code&gt;. In this scenario, the assumption is that the student moved to a jurisdiction outside of the data set, such as out of district for district-level data or out of state for state level data, and enrolled in at least one school not present in their enrollment record. The result is these students receive &lt;code&gt;2 moves&lt;/code&gt;&amp;ndash; one out from the &lt;code&gt;i&lt;/code&gt; school to a missing school and one in to the &lt;code&gt;i+1&lt;/code&gt; school from the missing school.&lt;/p&gt;

&lt;p&gt;The code looks like this (again a repeat from the &lt;code&gt;else{...&lt;/code&gt; above which was not using the &lt;code&gt;...&lt;/code&gt; character):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  }else{
    output[as.character(df[[sid]][i]), moves:=moves+2L] 
  }
}else...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ends with a &lt;code&gt;}&lt;/code&gt; which closes the &lt;code&gt;if&lt;/code&gt; conditional that checked if the &lt;code&gt;i+1&lt;/code&gt; student was the same as the &lt;code&gt;i&lt;/code&gt; student, leaving only one more business rule to check.&lt;/p&gt;

&lt;h3 id=&#34;business-rule-2-the-early-summer&#34;&gt;Business Rule 2: The Early Summer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;}else{
  if(is.na(df[[&#39;exit_date&#39;]][i])){
    next
  }else if(df[[&#39;exit_date&#39;]][i] &amp;lt; exitby){
        output[as.character(df[[sid]][i]), moves:=moves+1L]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall that this &lt;code&gt;else&lt;/code&gt; block is only called if &lt;code&gt;sid&lt;/code&gt; of the &lt;code&gt;i+1&lt;/code&gt; record is not the same as &lt;code&gt;i&lt;/code&gt;. This means that this is the final entry for a particular student. First, I check to see if that student has a missing &lt;code&gt;exit_date&lt;/code&gt; and if so charges no &lt;code&gt;move&lt;/code&gt; to the student implementing the &lt;code&gt;next&lt;/code&gt; statement to break out of this iteration of the loop. Students never have missing &lt;code&gt;enroll_date&lt;/code&gt; for any of the data I have seen over 8 years. This is because most systems minimally autogenerate the &lt;code&gt;enroll_date&lt;/code&gt; for the current date when a student first enters a student information system. However, sometimes districts forget to properly exit a student and are unable to supply an accurate &lt;code&gt;exit_date&lt;/code&gt;. In a very small number of cases I have seen these missing dates. So I do not want the function to fail in this scenario. My solution here was simply to break out and move to the next iteration of the loop.&lt;/p&gt;

&lt;p&gt;Finally, I apply the last rule, which compares the final &lt;code&gt;exit_date&lt;/code&gt; for a student to &lt;code&gt;exitby&lt;/code&gt;, incrementing &lt;code&gt;moves&lt;/code&gt; if the student left prior to the end of the year and likely enrolled elsewhere before the summer.&lt;/p&gt;

&lt;p&gt;The last step is to close the &lt;code&gt;for&lt;/code&gt; loop and &lt;code&gt;return&lt;/code&gt; our result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  }
  return(output)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;version-2-10x-speed-and-more-readable&#34;&gt;Version 2: 10x Speed And More Readable&lt;/h2&gt;

&lt;p&gt;The second version of this code is vastly quicker.&lt;/p&gt;

&lt;p&gt;The opening portion of the code, including the error checking is essentially a repeat of before, as is the initialization of the output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;moves_calc &amp;lt;- function(df, 
                       enrollby,
                       exitby,
                       gap=14,
                       sid=&#39;sasid&#39;, 
                       schid=&#39;schno&#39;,
                       enroll_date=&#39;enroll_date&#39;,
                       exit_date=&#39;exit_date&#39;){
  if(&amp;quot;data.table&amp;quot; %in% rownames(installed.packages()) == FALSE){
    install.packages(&amp;quot;data.table&amp;quot;)
  } 
  require(data.table)
  if (!inherits(df[[enroll_date]], &amp;quot;Date&amp;quot;) | !inherits(df[[exit_date]], &amp;quot;Date&amp;quot;))
      stop(&amp;quot;Both enroll_date and exit_date must be Date objects&amp;quot;)
  if(missing(enrollby)){
    enrollby &amp;lt;- as.Date(paste(year(min(df[[enroll_date]], na.rm=TRUE)),
                              &#39;-09-15&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
  }else{
    if(is.na(as.Date(enrollby, format=&amp;quot;%Y-%m-%d&amp;quot;))){
      enrollby &amp;lt;- as.Date(paste(year(min(df[[enroll_date]], na.rm=TRUE)),
                                &#39;-09-15&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
      warning(paste(&amp;quot;enrollby must be a string with format %Y-%m-%d,&amp;quot;,
                    &amp;quot;defaulting to&amp;quot;, 
                    enrollby, sep=&#39; &#39;))
    }else{
      enrollby &amp;lt;- as.Date(enrollby, format=&amp;quot;%Y-%m-%d&amp;quot;)
    }
  }
  if(missing(exitby)){
    exitby &amp;lt;- as.Date(paste(year(max(df[[exit_date]], na.rm=TRUE)),
                            &#39;-06-01&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
  }else{
    if(is.na(as.Date(exitby, format=&amp;quot;%Y-%m-%d&amp;quot;))){
      exitby &amp;lt;- as.Date(paste(year(max(df[[exit_date]], na.rm=TRUE)),
                                &#39;-06-01&#39;, sep=&#39;&#39;), format=&#39;%Y-%m-%d&#39;)
      warning(paste(&amp;quot;exitby must be a string with format %Y-%m-%d,&amp;quot;,
                    &amp;quot;defaulting to&amp;quot;, 
                    exitby, sep=&#39; &#39;))
    }else{
      exitby &amp;lt;- as.Date(exitby, format=&amp;quot;%Y-%m-%d&amp;quot;)
    }
  }
  if(!is.numeric(gap)){
    gap &amp;lt;- 14
    warning(&amp;quot;gap was not a number, defaulting to 14 days&amp;quot;)
  }
  output &amp;lt;- data.frame(id = as.character(unique(df[[sid]])),
                       moves = vector(mode = &#39;numeric&#39;, 
                                      length = length(unique(df[[sid]]))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where things start to get interesting is in the calculation of the number of student moves.&lt;/p&gt;

&lt;h3 id=&#34;handling-missing-data&#34;&gt;Handling Missing Data&lt;/h3&gt;

&lt;p&gt;One of the clever bits of code I forgot about when I initially tried to refactor Version 1 appears under &amp;ldquo;Business Rule 2: The Early Summer&amp;rdquo;. When the &lt;code&gt;exit_date&lt;/code&gt; is missing, this code simply breaks out of the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  if(is.na(df[[&#39;exit_date&#39;]][i])){
    next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the new code will not be utilizing &lt;code&gt;for&lt;/code&gt; loops or really any more of the basic control flow, I had to device a different way to treat missing data. The steps to apply the business rules that I present below will fail spectacularly with missing data.&lt;/p&gt;

&lt;p&gt;So the first thing that I do is select the students who have missing data, assign the &lt;code&gt;moves&lt;/code&gt; in the &lt;code&gt;output&lt;/code&gt; to &lt;code&gt;NA&lt;/code&gt;, and then subset the data to exclude these students.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;incomplete &amp;lt;- df[!complete.cases(df[, c(enroll_date, exit_date)]), ]
if(dim(incomplete)[1]&amp;gt;0){
  output[which(output[[&#39;id&#39;]] %in% incomplete[[sid]]),][[&#39;moves&#39;]] &amp;lt;- NA
}
output &amp;lt;- data.table(output, key=&#39;id&#39;)
df &amp;lt;- df[complete.cases(df[, c(enroll_date, exit_date)]), ]
dt &amp;lt;- data.table(df, key=sid)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;woe-with-data-table&#34;&gt;Woe with &lt;code&gt;data.table&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Now with the data complete and in a &lt;code&gt;data.table&lt;/code&gt;, I have to do a little bit of work to assist with my frustrations with &lt;code&gt;data.table&lt;/code&gt;. Because &lt;code&gt;data.table&lt;/code&gt; does a lot of work with the &lt;code&gt;[&lt;/code&gt; operator, I find it very challenging to use a string argument to reference a column in the data. So I just gave up and internally rename these attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dt$sasid &amp;lt;- as.factor(as.character(dt$sasid))
setnames(dt, names(dt)[which(names(dt) %in% enroll_date)], &amp;quot;enroll_date&amp;quot;)
setnames(dt, names(dt)[which(names(dt) %in% exit_date)], &amp;quot;exit_date&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;magic-with-data-table-business-rules-1-and-2-in-two-lines-each&#34;&gt;Magic with &lt;code&gt;data.table&lt;/code&gt;: Business Rules 1 and 2 in two lines each&lt;/h3&gt;

&lt;p&gt;Despite by challenges with the way that &lt;code&gt;data.table&lt;/code&gt; re-imagines &lt;code&gt;[&lt;/code&gt;, it does allow for clear, simple syntax for complex processes. Gone are the &lt;code&gt;for&lt;/code&gt; loops and conditional blocks. How does &lt;code&gt;data.table&lt;/code&gt; allow me to quickly identified whether or not a students first or last enrollment are before or after my cutoffs?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;first &amp;lt;- dt[, list(enroll_date=min(enroll_date)), by=sid]
output[id %in% first[enroll_date&amp;gt;enrollby][[sid]], moves:=moves+1L]
last &amp;lt;- dt[, list(exit_date=max(exit_date)), by=sid]  
output[id %in% last[exit_date&amp;lt;exitby][[sid]], moves:=moves+1L]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 1 creates a &lt;code&gt;data.table&lt;/code&gt; with the student identifier and a new &lt;code&gt;enroll_date&lt;/code&gt; column that is equal to the minimum &lt;code&gt;enroll_date&lt;/code&gt; for that student.&lt;/p&gt;

&lt;p&gt;The second line is very challenging to parse if you&amp;rsquo;ve never used &lt;code&gt;data.table&lt;/code&gt;. The first argument for &lt;code&gt;[&lt;/code&gt; in &lt;code&gt;data.table&lt;/code&gt; is a subset/select function. In this case,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;id %in% first[enroll_date&amp;gt;enrollby][[sid]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Select the rows in &lt;code&gt;first&lt;/code&gt; where the &lt;code&gt;enroll_date&lt;/code&gt; attribute (which was previously assigned as the minimum &lt;code&gt;enroll_date&lt;/code&gt;) is less than the global function argument &lt;code&gt;enrollby&lt;/code&gt; and check if the &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;output&lt;/code&gt; is in the &lt;code&gt;sid&lt;/code&gt; vector.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So &lt;code&gt;output&lt;/code&gt; is being subset to only include those records that meet that condition, in other words, the students who should have a move because they entered the school year late.&lt;/p&gt;

&lt;p&gt;The second argument of &lt;code&gt;[&lt;/code&gt; for &lt;code&gt;data.tables&lt;/code&gt; is explained in this footnote &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:increments&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:increments&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; if you&amp;rsquo;re not familiar with it.&lt;/p&gt;

&lt;h3 id=&#34;recursion-which-is-also-known-as-recursion&#34;&gt;Recursion. Which is also known as recursion.&lt;/h3&gt;

&lt;p&gt;The logic for Business Rules 3-5 are substantially more complex. At first it was not plainly obvious how to avoid a slow &lt;code&gt;for&lt;/code&gt; loop for this process. Each of the rules on switching schools requires an awareness of context&amp;ndash; how does one record of a student compare to the very next record for that student?&lt;/p&gt;

&lt;p&gt;The breakthrough was thinking back to my single semester of computer science and the concept of recursion. I created a new function inside of this function that can count how many moves are associated with a set of enrollment records, ignoring the considerations in Business Rules 1 and 2. Here&amp;rsquo;s my solution. I decided to include inline comments because I think it&amp;rsquo;s easier to understand that way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;school_switch &amp;lt;- function(dt, x=0){
  # This function accepts a data.table dt and initializes the output to 0.
    if(dim(dt)[1]&amp;lt;2){
    # When there is only one enrollment record, there are no school changes to
    # apply rules 3-5. Therefore, the function returns the value of x. If the
    # initial data.table contains a student with just one enrollment record, 
    # this function will return 0 since we initialize x as 0.
      return(x)
    }else{
      # More than one record, find the minimum exit_date which is the &amp;quot;first&amp;quot;
      # record
      exit &amp;lt;- min(dt[, exit_date])
      # Find out which school the &amp;quot;first&amp;quot; record was at.
      exit_school &amp;lt;- dt[exit_date==exit][[schid]]
      # Select which rows come after the &amp;quot;first&amp;quot; record and only keep them
      # in the data.table
      rows &amp;lt;- dt[, enroll_date] &amp;gt; exit
      dt &amp;lt;- dt[rows,]
      # Find the minimum enrollment date in the subsetted table. This is the
      # enrollment that follows the identified exit record
      enroll &amp;lt;- min(dt[, enroll_date])
      # Find the school associated with that enrollment date
      enroll_school &amp;lt;- dt[enroll_date==enroll][[schid]]
      # When the difference between the enrollment and exit dates are less than
      # the gap and the schools are the same, there are no moves. We assign y,
      # our count of moves to x, whatever the number of moves were in this call
      # of school_switch
      if(difftime(min(dt[, enroll_date], na.rm=TRUE), exit) &amp;lt; gap &amp;amp;
         exit_school==enroll_school){
        y = x
      # When the difference in days is less than the gap (and the schools are
      # different), then our number of moves are incremented by 1.
      }else if(difftime(min(dt[, enroll_date], na.rm=TRUE), exit) &amp;lt; gap){
        y = x + 1L
      }else{
      # Whenever the dates are separated by more than the gap, regardless of which
      # school a student is enrolled in at either point, we increment by two.
        y = x + 2L
      }
      # Explained below outside of the code block.
      school_switch(dt, y)
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The recursive aspect of this method is calling &lt;code&gt;school_switch&lt;/code&gt; within &lt;code&gt;school_switch&lt;/code&gt; once the function reaches its end. Because I subset out the row with the minimum &lt;code&gt;exit_date&lt;/code&gt;, the &lt;code&gt;data.table&lt;/code&gt; has one row processed with each iteration of &lt;code&gt;school_switch&lt;/code&gt;. By passing the number of moves, &lt;code&gt;y&lt;/code&gt; back into &lt;code&gt;school_switch&lt;/code&gt;, I am &amp;ldquo;saving&amp;rdquo; my work from each iteration. Only when a single row remains for a particular student does the function &lt;code&gt;return&lt;/code&gt; a value.&lt;/p&gt;

&lt;p&gt;This function is called using &lt;code&gt;data.table&lt;/code&gt;&amp;rsquo;s special &lt;code&gt;.SD&lt;/code&gt; object, which accesses the subset of the full &lt;code&gt;data.table&lt;/code&gt; when using the &lt;code&gt;by&lt;/code&gt; argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dt[, moves:= school_switch(.SD), by=sid]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This calls &lt;code&gt;school_switch&lt;/code&gt; after splitting the &lt;code&gt;data.table&lt;/code&gt; by each &lt;code&gt;sid&lt;/code&gt; and then stitches the work back together, split-apply-combine style, resulting in a &lt;code&gt;data.table&lt;/code&gt; with a set of &lt;code&gt;moves&lt;/code&gt; per student identifier. With a little bit of clean up, I can simply add these moves to those recorded earlier in &lt;code&gt;output&lt;/code&gt; based on Business Rules 1 and 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  dt &amp;lt;- dt[,list(switches=unique(moves)), by=sid]
  output[dt, moves:=moves+switches]
  return(output)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quick-and-dirty-system-time&#34;&gt;Quick and Dirty &lt;code&gt;system.time&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:optimization&#34;&gt;On a mid-2012 Macbook Air, the current mobility calculation is very effective with tens of thousands of student records and practical for use in the low-hundreds of thousands of records range.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:optimization&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:increments&#34;&gt;I thought I was going to use &lt;code&gt;data.table&lt;/code&gt; for some of its speedier features as I wrote this initial function. I didn&amp;rsquo;t in this go (though I do in Version 2). However, I do find the &lt;code&gt;data.table&lt;/code&gt; syntax for assigning values to be really convenient, particularly the &lt;code&gt;:=&lt;/code&gt; operator which is common in several other languages. In &lt;code&gt;data.table&lt;/code&gt;, the syntax &lt;code&gt;dt[,name:=value]&lt;/code&gt; assigns &lt;code&gt;value&lt;/code&gt; to an exist (or new) column called &lt;code&gt;name&lt;/code&gt;. Because of the need &lt;code&gt;select&lt;/code&gt; operator in &lt;code&gt;data.table&lt;/code&gt;, I can just use &lt;code&gt;dt[id,moves:=moves+1L]&lt;/code&gt; to select only the rows where the table &lt;code&gt;key&lt;/code&gt;, in this case &lt;code&gt;sid&lt;/code&gt;, matches &lt;code&gt;id&lt;/code&gt;, and then increment &lt;code&gt;moves&lt;/code&gt;. Nice.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:increments&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:increments&#34;&gt;I thought I was going to use &lt;code&gt;data.table&lt;/code&gt; for some of its speedier features as I wrote this initial function. I didn&amp;rsquo;t in this go (though I do in Version 2). However, I do find the &lt;code&gt;data.table&lt;/code&gt; syntax for assigning values to be really convenient, particularly the &lt;code&gt;:=&lt;/code&gt; operator which is common in several other languages. In &lt;code&gt;data.table&lt;/code&gt;, the syntax &lt;code&gt;dt[,name:=value]&lt;/code&gt; assigns &lt;code&gt;value&lt;/code&gt; to an exist (or new) column called &lt;code&gt;name&lt;/code&gt;. Because of the need &lt;code&gt;select&lt;/code&gt; operator in &lt;code&gt;data.table&lt;/code&gt;, I can just use &lt;code&gt;dt[id,moves:=moves+1L]&lt;/code&gt; to select only the rows where the table &lt;code&gt;key&lt;/code&gt;, in this case &lt;code&gt;sid&lt;/code&gt;, matches &lt;code&gt;id&lt;/code&gt;, and then increment &lt;code&gt;moves&lt;/code&gt;. Nice.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:increments&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A New Calculation for Student Mobility</title>
      <link>http://www.jsonbecker.com/2013/09/a-new-calculation-for-student-mobility</link>
      <pubDate>Tue, 17 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://www.jsonbecker.com/2013/09/a-new-calculation-for-student-mobility</guid>
      <description>

&lt;p&gt;How do we calculate student mobility? I am currently soliciting responses from other data professionals across the country. But when I needed to produce mobility numbers for some of my work a couple of months ago, I decided to develop a set of business rules without any exposure to how the federal government, states, or other existing systems define mobility. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ignorance&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ignorance&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;I am fairly proud of my work on mobility. This post will review how I defined student mobility. I am hopeful that it matches or bests current techniques for calculating the number of schools a student has attended. In my next post, I will share the first two major versions of my implementation of these mobility business rules in &lt;code&gt;R&lt;/code&gt;. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:learningexperience&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:learningexperience&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; Together, these posts will represent the work I referred to in my previous post on the &lt;a href=&#34;|filename|documentation-of-business-rules-and-analysis.md&#34;&gt;importance of documenting business rules and sharing code&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-rules&#34;&gt;The Rules&lt;/h2&gt;

&lt;p&gt;Working with district data presents a woefully incomplete picture of the education mobile students receive. Particularly in a state like Rhode Island, where our districts are only a few miles wide, there is substantial interdistrict mobility. When a student moves across district lines, their enrollment is not recorded in local district data. However, even with state level data, highly mobile students cross state lines and present incomplete data. A key consideration for calculating how many schools a student has attended in a particular year is capturing &amp;ldquo;missing&amp;rdquo; data sensibly.&lt;/p&gt;

&lt;p&gt;The typical structure of enrollment records looks something like this:&lt;/p&gt;

&lt;p&gt;| Unique Student ID | School Code | Enrollment Date | Exit Date ||
|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|
| 1000000           | 10101       | 2012-09-01      | 2012-11-15 |
| 1000000           | 10103       | 2012-11-16      | 2013-06-15 |&lt;/p&gt;

&lt;p&gt;A compound key for this data consists of the Unique Student ID, School Code, and Enrollment Date, meaning that each row must be a unique combination of these three factors. The data above shows a simple case of a student enrolling at the start of the school year, switching schools once with no gap in enrollment, and continuing at the new school until the end of the school year. For the purposes of mobility, I would define the above as having moved one time.&lt;/p&gt;

&lt;p&gt;But it is easy to see how some very complex scenarios could quickly arise. What if student &lt;code&gt;1000000&lt;/code&gt;&amp;rsquo;s record looked like this?&lt;/p&gt;

&lt;p&gt;| Unique Student ID | School Code | Enrollment Date | Exit Date ||
|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|
| 1000000           | 10101       | 2012-10-15      | 2012-11-15 |
| 1000000           | 10103       | 2013-01-03      | 2013-03-13 |
| 1000000           | 10103       | 2013-03-20      | 2013-05-13 |&lt;/p&gt;

&lt;p&gt;There are several features that make it challenging to assign a number of &amp;ldquo;moves&amp;rdquo; to this student. First, the student does not enroll in school until October 15, 2012. This is nearly six weeks into the typical school year in the Northeastern United States. Should we assume that this student has enrolled in no school at all prior to October 15th or should we assume that the student was enrolled in a school that was outside of this district and therefore missing in the data? Next, we notice the enrollment gap between November 15, 2012 and January 3, 2013. Is it right to assume that the student has moved only once in this period of time with a gap of enrollment of over a month and a half? Then we notice that the student exited school &lt;code&gt;10103&lt;/code&gt; on March 13, 2013 but was re-enrolled in the same school a week later on March 20, 2013. Has the student truly &amp;ldquo;moved&amp;rdquo; in this period? Lastly, the student exits the district on May 13, 2013 for the final time. This is nearly a month before the end of school. Has this student moved to a different school?&lt;/p&gt;

&lt;p&gt;There is an element missing that most enrollment data has which can enrich our understanding of this student&amp;rsquo;s record. All district collect an exit type, which explains if a student is leaving to enroll in another school within the district, another school in a different district in the same state, another school in a different state, a private school, etc. It also defines whether a student is dropping out, graduating, or has entered the juvenile justice system, for example. However, it has been my experience that this data is reported inconsistently and unreliably. Frequently a student will be reported as changing schools within the district without a subsequent enrollment record, or reported as leaving the district but enroll within the same district a few days later. Therefore, I think that we should try and infer the number of schools that a student has attended using soley the enrollment date, exit date, and school code for each student record. This data is far more reliable for a host of reasons, and, ultimately, provides us with all the information we need to make intelligent decisions.&lt;/p&gt;

&lt;p&gt;My proposed set of business rules examines &lt;code&gt;school code&lt;/code&gt;, &lt;code&gt;enrollment date&lt;/code&gt;, and &lt;code&gt;exit date&lt;/code&gt; against three parameters: &lt;code&gt;enrollment by&lt;/code&gt;, &lt;code&gt;exit by&lt;/code&gt;, and &lt;code&gt;gap&lt;/code&gt;.
Each students minimum enrollment date is compared to &lt;code&gt;enrollment by&lt;/code&gt;. If that student entered the data set for the first time before the &lt;code&gt;enrollment by&lt;/code&gt;, the assumption is that this record represents the first time the student enrolls in any school for that year, and therefore the student has 0 &lt;code&gt;moves&lt;/code&gt;. If the student enrolls for the first time after &lt;code&gt;enrollment by&lt;/code&gt;, then the record is considered the second school a student has attended and their &lt;code&gt;moves&lt;/code&gt; attribute is incremented by &lt;code&gt;1&lt;/code&gt;. Similarly, if a student&amp;rsquo;s maximium &lt;code&gt;exit date&lt;/code&gt; is after &lt;code&gt;exit by&lt;/code&gt;, then this considered to be the student&amp;rsquo;s last school enrolled in for the year and they are credited with &lt;code&gt;0&lt;/code&gt; &lt;code&gt;moves&lt;/code&gt;, but if &lt;code&gt;exit date&lt;/code&gt; is prior to &lt;code&gt;exit by&lt;/code&gt;, then that student&amp;rsquo;s &lt;code&gt;moves&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That takes care of the &amp;ldquo;ends&amp;rdquo;, but what happens as students switch schools in the &amp;ldquo;middle&amp;rdquo;? I proposed that each &lt;code&gt;exit date&lt;/code&gt; is compared to the subsequent &lt;code&gt;enrollment date&lt;/code&gt;. If &lt;code&gt;enrollment date&lt;/code&gt; occurs within &lt;code&gt;gap&lt;/code&gt; days of the previous &lt;code&gt;exit date&lt;/code&gt;, and the &lt;code&gt;school code&lt;/code&gt; of enrollment is not the same as the &lt;code&gt;school code&lt;/code&gt; of exit, then a student&amp;rsquo;s &lt;code&gt;moves&lt;/code&gt; are incremented by &lt;code&gt;1&lt;/code&gt;. If the &lt;code&gt;school codes&lt;/code&gt; are identical and the difference between dates is less than &lt;code&gt;gap&lt;/code&gt;, then the student is said to have not moved at all. If the difference between the &lt;code&gt;enrollment date&lt;/code&gt; and the previous &lt;code&gt;exit date&lt;/code&gt; is greater than &lt;code&gt;gap&lt;/code&gt;, then the student&amp;rsquo;s &lt;code&gt;moves&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;, the assumption being that the student likely attended a different school between the two observations in the data.&lt;/p&gt;

&lt;p&gt;Whereas calculating student mobility may have seemed a simple matter of counting the number of records in the enrollment file, clearly there is a level of complexity this would fail to capture.&lt;/p&gt;

&lt;p&gt;Check back in a few days to see my next post where I will share my initial implementation of these business rules and how I achieved an 10x speed up with a massive code refactor.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ignorance&#34;&gt;My ignorance was intentional. It is good to stretch those brain muscles that think through sticky problems like developing business rules for a key statistic. I can&amp;rsquo;t be sure that I have developed the most considered and complete set of rules for mobility, which is why I&amp;rsquo;m now soliciting other&amp;rsquo;s views, but I am hopeful my solution is at least as good.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ignorance&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:learningexperience&#34;&gt;I think showing my first two implementation of these business rules is an excellent opportunity to review several key design considerations when programming in &lt;code&gt;R&lt;/code&gt;. From version 1 to version 2 I achieved a 10x speedup due to a complete refactor that avoided &lt;code&gt;for&lt;/code&gt; loops, used &lt;code&gt;data.table&lt;/code&gt;, and included some clever use of recursion.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:learningexperience&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Documentation of Business Rules and Analysis</title>
      <link>http://www.jsonbecker.com/2013/09/documentation-of-business-rules-and-analysis</link>
      <pubDate>Fri, 13 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://www.jsonbecker.com/2013/09/documentation-of-business-rules-and-analysis</guid>
      <description>&lt;p&gt;One of the most challenging aspects of being a data analyst is translating programmatic terms like &amp;ldquo;student mobility&amp;rdquo; into precise business rules. Almost any simple statistic involves a series of decisions that are often opaque to the ultimate users of that statistic.&lt;/p&gt;

&lt;p&gt;Documentation of business rules is a critical aspect of a data analysts job that, in my experience, is often regrettably overlooked. If you have ever tried to reproduce someone else&amp;rsquo;s analysis, asked different people for the same statistic, or tried to compare data from multiple years, you have probably encountered difficulties getting a consistent answer on standard statistics, e.g. how many students were proficient in math, how many students graduated in four years, what proportion of students were chronically absent? All too often documentation of business rules is poor or non-existent. The result is that two analysts with the same data will produce inconsistent statistics. This is not because of something inherent in the quality of the data or an indictment of the analysts skills. In most cases, the undocumented business rules are essentially trivial, in that the results of any decision has a small impact on the final result and any of the decisions made by the analysts are equally defensible.&lt;/p&gt;

&lt;p&gt;This major problem of lax or non-existent documentation is one of the main reasons I feel that analysts, and in particular analysts working in the public sector, should extensively use tools for code sharing and version control like &lt;a href=&#34;http://www.github.com/&#34;&gt;Github&lt;/a&gt;, use free tools whenever possible, and generally adhere to best practices in reproducible research.&lt;/p&gt;

&lt;p&gt;I am trying to put as much of my code on Github as I can these days. Much of what I write is still very disorganized and, frankly, embarrassing. A lot of what is in my Github repositories is old, abandoned code written as I was learning my craft. A lot of it is written to work with very specific, private data. Most of it is poorly documented because I am the only one who has ever had to use it, I don&amp;rsquo;t interact with anyone through practices like code reviews, and frankly I am lazy when pressed with a deadline. But that&amp;rsquo;s not really the point, is it? The worst documented code is code that is hidden away on a personal hard drive, written for an expensive proprietary environment most people and organizations cannot use, or worse, is not code at all but rather a series of destructive data edits and manipulations. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fuckexcel&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fuckexcel&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;One way that I have been trying to improve the quality and utility of the code I write is by contributing to an open source R package, &lt;code&gt;eeptools&lt;/code&gt;. This is a package written and maintained by Jared Knowles, an employee of the Wisconsin Department of Public Instruction, whom I met at a &lt;a href=&#34;http://www.gse.harvard.edu/sdp/&#34;&gt;Strategic Data Project&lt;/a&gt; convening. &lt;code&gt;eeptools&lt;/code&gt; is consolidating several functions in R for common tasks education data analysts are faced with. Because this package is available on &lt;a href=&#34;http://cran.us.r-project.org/&#34;&gt;CRAN&lt;/a&gt;, the primary repository for R packages, any education analyst can have access to its functions in one line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#39;eeptools&#39;); require(eeptools)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Submitting code to a CRAN package reinforces several habits. First, I get to practice writing R documentation,  explaining how to use a function, and therefore, articulating the assumptions and business rules I am applying. Second, I have to write my code with a wider tolerance for input data. One of the easy pitfalls of a beginning analyst is writing code that is too specific to the dataset in front of you. Most of the errors I have found in analyses during quality control stem from assumptions embedded in code that were perfectly reasonable with a single data set that lead to serious errors when using different data. One way to avoid this issue is through &lt;a href=&#34;http://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;test-driven development&lt;/a&gt;, writing a good testing suite that tests a wide range of unexpected inputs. I am not quite there yet, personally, but thinking about how my code would have to work with arbitrary inputs and ensuring it fails gracefully &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fallingwithstyle&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fallingwithstyle&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; is an excellent side benefit of preparing a pull request &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:gitterms&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:gitterms&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; . Third, it is an opportunity to write code for someone other than myself. Because I am often the sole analyst with my skillset working on a project, it is easy to not consider things like style, optimizations, clarity, etc. This can lead to large build-ups of &lt;a href=&#34;http://en.wikipedia.org/wiki/Technical_debt&#34;&gt;technical debt&lt;/a&gt;, complacency toward learning new techniques, and general sloppiness. Submitting a pull request feels like publishing. The world has to read this, so it better be something I am proud of that can stand up to the scrutiny of third-party users.&lt;/p&gt;

&lt;p&gt;My first pull request, which was accepted into the package, calculates age in years, months, or days at an arbitrary date based on date of birth. While even a beginning R programmer can develop a similar function, it is the perfect example of an easily compartmentalized component, with a broad set of applications, that can be accessed frequently .&lt;/p&gt;

&lt;p&gt;Today I submitted by second pull request that I hope will be accepted. This time I covered a much more complex task&amp;ndash; calculating student mobility. To be honest, I am completely unaware of existing business rules and algorithms used to produce the mobility numbers that are federally reported. I wrote this function from scratch thinking through how I would calculate the number of schools attended by a student in a given year. I am really proud of both the business rules I have developed and the code I wrote to apply those rules. My custom function can accept fairly arbitrary inputs, fails gracefully when it finds data it does not expect, and is pretty fast. The original version of my code took close to 10 minutes to run on ~30,000 rows of data. I have reduced that with a complete rewrite prior to submission to 16 seconds.&lt;/p&gt;

&lt;p&gt;While I am not sure if this request will be accepted, I will be thrilled if it is. Mobility is a tremendously important statistic in education research and a standard, reproducible way to calculate it would be a great help to researchers. How great would it be if &lt;code&gt;eeptools&lt;/code&gt; becomes one of the first packages education data analysts load and my mobility calculations are used broadly by researchers and analysts? But even if its not accepted because it falls out of scope, the process of developing the business rules, writing an initial implementation of those rules, and then refining that code to be far simpler, faster, and less error prone was incredibly rewarding.&lt;/p&gt;

&lt;p&gt;My next post will probably be a review of that process and some parts of my &lt;code&gt;moves_calc&lt;/code&gt; function that I&amp;rsquo;m particularly proud of.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fuckexcel&#34;&gt;Using a spreadsheet program, such as Excel, encourages directly manipulating and editing the source data. Each change permanently changes the data. Even if you keep an original version of the data, there is no recording of exactly what was done to change the data to produce your results. Reproducibility is all but impossible of any significant analysis done using spreadsheet software.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fuckexcel&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fallingwithstyle&#34;&gt;Instead of halting the function with hard to understand error when things go wrong, I do my best to &amp;ldquo;correct&amp;rdquo; easily anticipated errors or report back to users in a plain way what needs to be fixed. See also &lt;a href=&#34;http://en.wikipedia.org/wiki/Fault-tolerant_system&#34;&gt;fault-tolerant system&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fallingwithstyle&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:gitterms&#34;&gt;A &lt;a href=&#34;https://help.github.com/articles/using-pull-requests&#34;&gt;pull request&lt;/a&gt; is when you submit your additions, deletions, or any other modifications to be incorporated in someone else&amp;rsquo;s repository.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:gitterms&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>