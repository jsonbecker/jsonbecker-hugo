<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code Pelican Python Regex Wordpress on JSONBecker</title>
    <link>http://www.json.blog/tags/code-pelican-python-regex-wordpress/</link>
    <description>Recent content in Code Pelican Python Regex Wordpress on JSONBecker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Dec 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.json.blog/tags/code-pelican-python-regex-wordpress/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Slow Trek to Pelican</title>
      <link>http://www.json.blog/2012/12/the-slow-trek-to-pelican</link>
      <pubDate>Thu, 20 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.json.blog/2012/12/the-slow-trek-to-pelican</guid>
      <description>

&lt;p&gt;&lt;em&gt;Update: Please see below for two solutions.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I have grown increasingly unhappy with Wordpress lately. My blog is simple. My design tastes are simple. My needs are simple. I like control. I am a geek. And I really need an excuse to learn Python, which seems to be rapidly growing into one of the most important programming languages for a data analyst.&lt;/p&gt;

&lt;p&gt;I have decided to migrate this blog over to &lt;a href=&#34;http://docs.getpelican.com/en/3.1.1/&#34;&gt;Pelican&lt;/a&gt;, a static site generator written in Python. Static sites are the &amp;ldquo;classic&amp;rdquo; way to do a webpage&amp;ndash; just upload a bunch of HTML and CSS files, maybe some Javascript. But no databases and no constructing the page a user sees in the browser as they request it. This puts substantially less strain on a web server and makes it far easier to export and move a webpage since all you need to do is duplicate files. What makes static sites a real pain is that there is a lot of repetition. Folks adopted dynamic sites that use content management system so that they can write a page called &amp;ldquo;post.php&amp;rdquo; one time, and for each unique post just query a database for the unique content. The frame around the post, layout, components, etc are all just written once. Static site generators allow you to build a webpage using a similar, but far more stripped down, layout system. However, rather than generate each page on the web server, you generate each page by running a script locally that transforms plain text documents into well-formed HTML/CSS. Then you can just upload a directory and the whole site is ready to go.&lt;/p&gt;

&lt;p&gt;Pelican comes with a pretty good script that will take Wordpress XML that&amp;rsquo;s available via the built-in export tools and transform each post into a &lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34;&gt;reStructuredText&lt;/a&gt; files, a format similar to &lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;Markdown&lt;/a&gt;. I prefer Markdown so I used &lt;a href=&#34;http://johnmacfarlane.net/pandoc/&#34;&gt;pandoc&lt;/a&gt; to convert all my *.rst posts into *.md files.&lt;/p&gt;

&lt;p&gt;So far, so good.&lt;/p&gt;

&lt;p&gt;But one of the really big problems I had with Wordpress was a growing dependency on plugins that added non-standard, text-based markup in my posts that would be rendered a particular way. For example, text surrounded by two parenthesis, &amp;lsquo;[^0]&amp;lsquo;, became a footnote. For code syntax highlighting, I use a &amp;ldquo;short code&amp;rdquo;, which puts &amp;ldquo;sourcecode language=&amp;lsquo;r&amp;rsquo;&amp;rdquo;, for example, between brackets []. All of these plugins have been great, but now when you try to export a post you get the non-standard markup in-line as part of your posts. It makes it very difficult to recreate a post the way it looks today.&lt;/p&gt;

&lt;p&gt;This presents a great opportunity to learn a little Python. So I have begun to scrounge together some basic Python knowledge to write some scripts to clean up my Markdown files and convert the syntax of the short codes that I have used to properly formatted Markdown so that when I run the pelican script it will accurately reproduce each post.&lt;/p&gt;

&lt;p&gt;Unfortunately, I&amp;rsquo;ve hit a snag with my very first attempt. Footnotes are a big deal to me and have standard Markdown interpretation. In Markdown, footnotes are inserted in the text where &amp;ldquo;[\^#]&amp;rdquo; appears in the text, where # = the footnote identifier/key. Then, at the end of the document, surrounded by new lines, the footnote text is found with &amp;ldquo;[\^#]: footnote text&amp;rdquo; where # is the same identifier. So I needed to write a script that found each instance of text surrounded by two parentheses, insert the [\^#] part in place of the footnote, and then add the footnote at the bottom of the post in the right format.&lt;/p&gt;

&lt;p&gt;I created a test text file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:::
This is a test ((test footnote)).
And here is another test ((footnote2)). Why not add a third? ((Three
Three)).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The goal was to end up with a file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:::
This is a test [^1]. And here is another
test [^2]. Why not add a third? [^3].

[^1]: test footnote

[^2]: footnote2

[^3]: Three Three
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, the output isn&amp;rsquo;t quite right. My best attempt resulted in
a file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:::
This is a test [^1] And here is another te[^2])). Why not add a
t[^3]ree)).

[^1]: ((test footnote))

[^2]: ((footnote2))

[^3]: ((Three Three))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ugh.&lt;/p&gt;

&lt;p&gt;So I am turning to the tiny slice of my readership that might actually know Python or just code in general to help me out. Where did I screw up? The source to my Python script is below so feel free to comment here or on this &lt;a href=&#34;https://gist.github.com/4342554#file-wpfootnotestomarkdown-py&#34;&gt;Gist&lt;/a&gt;. I am particularly frustrate that the regex appears to be capturing the parenthesis, because that&amp;rsquo;s not how the same code behaves on &lt;a href=&#34;http://www.pythonregex.com&#34;&gt;PythonRegex.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If anyone can help me with the next step, which will be creating arguments that will understand an input like *.rst and set the output to creating a file that&amp;rsquo;s *.md, that would be appreciated as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:::python
import re

p = re.compile(&amp;quot;\(\(([^\(\(\)\)]+)\)\)&amp;quot;)
file_path = str(raw_input(&#39;File Name &amp;gt;&#39;))
text = open(file_path).read()

footnoteMatches = p.finditer(text)

coordinates = []
footnotes = []

# Print span of matches
for match in footnoteMatches:
    coordinates.append(match.span())
    footnotes.append(match.group())

for i in range(0,len(coordinates)):
    text = (text[0:coordinates[i][0]] + &#39;[^&#39; + str(i+1)+ &#39;]&#39; +
            text[coordinates[i][1]+1:])
    shift = coordinates[i][1] - coordinates[i][0]
    j = i + 1
    while j &amp;lt; len(coordinates):
        coordinates[j] = (coordinates[j][0] - shift, coordinates[j][1] - shift)
        j += 1

referenceLinkList = [text 1=&amp;quot;&#39;
&#39;&amp;quot; language=&amp;quot;,&amp;quot;][/text]
for i in range(0, len(footnotes)):
    insertList = &#39;&#39;.join([&#39;\n&#39;, &#39;[^&#39;, str(i+1), &#39;]: &#39;, footnotes[i], &#39;\n&#39;])
    referenceLinkList.append(insertList)

text = &#39;&#39;.join(referenceLinkList)

newFile = open(file_path, &#39;w&#39;)
newFile.truncate()
newFile.write(text)
newFile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-with-solutions&#34;&gt;Update with solutions:&lt;/h2&gt;

&lt;p&gt;I am happy to report I now have two working solutions. The first one comes courtesy of &lt;a href=&#34;https://github.com/ilikepi&#34;&gt;James Blanding&lt;/a&gt; who was kind enough to &lt;a href=&#34;https://gist.github.com/4355865&#34;&gt;fork&lt;/a&gt; the gist I put up. While I was hoping to take a look tonight at his fork tonight, &lt;a href=&#34;http://news.ycombinator.com/item?id=4957935&#34;&gt;Github was experiencing some downtime&lt;/a&gt;.  So I ended up fixing the script myself a slightly different way (seen below). I think James&amp;rsquo;s approach is superior for a few reasons, not the least of which was avoiding the ugly if/elif/else found in my code by using a global counter. He also used .format() a lot better than I did, which I didn&amp;rsquo;t know existed until I found it tonight.&lt;/p&gt;

&lt;p&gt;I made two other changes before coming to my solution. First, I realized my regex was completely wrong. I didn&amp;rsquo;t want to capture anything within the two parenthesis when no parenthesis were contained, as the original regex did. Instead, I wanted to make sure to preserve any parenthetical comments contained within my footnotes. So the resulting regex looks a bit different. I also switched from using user input to taking in the filepath as an argument.&lt;/p&gt;

&lt;p&gt;My next step will be to learn a bit more about the os module which seems to contain what I need so that this Python script can behave like a good Unix script and know what to do with one file or a list of files as a parameter (and of course, most importantly, a list generated from a wild card like *.rst). I will also be incorporating the bits of James&amp;rsquo;s code that I feel confident I understand and that I like better.&lt;/p&gt;

&lt;p&gt;Without further ado, my solution (I updated the gist as well):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:::python
from sys import argv
import re

name, file_path = argv

p = re.compile(r&amp;quot;[\s]\(\((.*?[)]{0,1})\)\)[\s]{0,1}&amp;quot;)
# The tricky part here is to match all text between &amp;quot;((&amp;quot;&amp;quot;))&amp;quot;, including as 
# many as one set of (), which may even terminate ))). The {0,1} captures as
# many as one ). The trailing space is there because I often surrounded the 
# &amp;quot;((&amp;quot;&amp;quot;))&amp;quot; with a space to make it clear in the WordPress editor.

# file_path = str(raw_input(&#39;File Name &amp;gt;&#39;))
text = open(file_path).read()

footnoteMatches = p.finditer(text)

coordinates = []
footnotes = []

# Print span of matches
for match in footnoteMatches:
    coordinates.append(match.span())
# Capture only group(1) so you get the content of the footnote, not the 
# whole pattern which includes the parenthesis delimiter.
    footnotes.append(match.group(1))

newText = []
for i in range(0, len(coordinates)):
    if i == 0:
        newText.append(&#39;&#39;.join(text[:coordinates[i][0]] +
                               &#39; [^{}]&#39;).format(i + 1))
    elif i &amp;lt; len(coordinates) - 1 :
        newText.append(&#39;&#39;.join(text[coordinates[i-1][1]:coordinates[i][0]] +
                          &#39; [^{}]&#39;).format(i + 1))
    else:
        newText.append(&#39;&#39;.join(text[coordinates[i-1][1]:coordinates[i][0]] +
                          &#39; [^{}]&#39;).format(i + 1))
        # Accounts for text after the last footnote which only runs once.
        newText.append(text[coordinates[i][1]:]+&#39;\n&#39;)

endNotes = []
for j in range(0, len(footnotes)):
    insertList = &#39;&#39;.join([&#39;\n&#39;,&#39;[^{}]: &#39;, footnotes[j], &#39;\n&#39;]).format(j + 1)
    endNotes.append(insertList)

newText = &#39;&#39;.join(newText) + &#39;\n&#39; + &#39;&#39;.join(endNotes)

newFile = open(file_path, &#39;w&#39;)
newFile.truncate()
newFile.write(newText)
newFile.close()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>