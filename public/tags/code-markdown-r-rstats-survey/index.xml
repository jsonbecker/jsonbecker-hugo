<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code Markdown R Rstats Survey on JSONBecker</title>
    <link>/tags/code-markdown-r-rstats-survey/</link>
    <description>Recent content in Code Markdown R Rstats Survey on JSONBecker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Aug 2012 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/code-markdown-r-rstats-survey/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>There must be an easier way... survey questions in R</title>
      <link>/2012/08/there-must-be-an-easier-way...-survey-questions-in-r/</link>
      <pubDate>Wed, 22 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/08/there-must-be-an-easier-way...-survey-questions-in-r/</guid>
      <description>&lt;p&gt;So I have this great little custom function I&amp;rsquo;ve used when looking at survey data in R. I call this function &lt;code&gt;pull()&lt;/code&gt;. The goal of &lt;code&gt;pull()&lt;/code&gt; is to quickly produce frequency tables with n sizes from individual-level survey data.&lt;/p&gt;

&lt;p&gt;Before using &lt;code&gt;pull()&lt;/code&gt;, I create a big table that includes information about the survey questions I want to pull. The data are structured like this:&lt;/p&gt;

&lt;p&gt;&lt;table align=&#34;center&#34;&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;tbody&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;tr&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
quest&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
survey&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
year&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
break&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/tr&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;tr&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
ss01985&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
elementary&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
2011_12&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;td&gt;
schoolcode&lt;/p&gt;

&lt;p&gt;&lt;/td&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/tr&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/tbody&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/table&gt;
&lt;/p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;quest represents the question coding in the raw survey data.&lt;/li&gt;
&lt;li&gt;survey is the name of the survey (in my case, the elementary school students, middle school students, high school students, parents, teachers, or administrators).&lt;/li&gt;
&lt;li&gt;year is the year that the survey data are collected.&lt;/li&gt;
&lt;li&gt;break is the ID I want to aggregate on like schoolcode or districtcode.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They key is that &lt;code&gt;paste(survey, year,sep=&#39;&#39;)&lt;/code&gt; produces the name of the &lt;code&gt;data.frame&lt;/code&gt; where I store the relevant survey data. Both quest and break are columns in the survey data.frame. Using a data.frame with this data allows me to apply through the rows and produce the table for all the relevant questions at once. &lt;code&gt;pull()&lt;/code&gt; does the work of taking one row of this &lt;code&gt;data.frame&lt;/code&gt; and producing the output that I&amp;rsquo;m looking for. I also use &lt;code&gt;pull()&lt;/code&gt; one row at a time to save a data.frame that contains these data and do other things (like the visualizations in this post).&lt;/p&gt;

&lt;p&gt;In some sense, &lt;code&gt;pull()&lt;/code&gt; is really just a fancy version of &lt;code&gt;prop.table&lt;/code&gt; that takes in passed paramaters and adds an &amp;ldquo;n&amp;rdquo; to each row and adding a &amp;ldquo;total&amp;rdquo; row. I feel as though there must be an implementation of an equivalent function in a popular package (or maybe even base) that I should be using rather than this technique. It would probably be more maintainable and easier for collaborators to work with this more common implementation, but I have no idea where to find it. So, please feel free to use the code below, but I&amp;rsquo;m actually hoping that someone will chime in and tell me I&amp;rsquo;ve wasted my time and I should just be using some function foo::bar.&lt;/p&gt;

&lt;p&gt;P.S. This post is a great example of why I really need to change this blog to Markdown/R-flavored Markdown. All those inline references to functions, variables, or code should really be formatted in-line which the syntax highlighter plug-in used on this blog does not support. I&amp;rsquo;m nervous that using WP-Markdown plugin will botch formatting on older posts, so I may just need to setup a workflow where I pump out HTML from the Markdown and upload the posts from there. If anyone has experience with Markdown + Wordpress, advice is appreciated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pull &amp;lt;- function(rows){
  # Takes in a vector with all the information required to create crosstab with
  # percentages for a specific question for all schools.
  # Args:
  #  rows: Consists of a vector with four objects.
  #        quest: the question code from SurveyWorks
  #        level: the &amp;quot;level&amp;quot; of the survey, i.e.: elem, midd, high, teac, admn,
  #        pare, etc.
  #        year: the year the survey was administered, i.e. 2011_12
  #        sch_lea: the &amp;quot;break&amp;quot; indicator, i.e. schoolcode, districtcode, etc.
  # Returns:
  # A data.frame with a row for each &amp;quot;break&amp;quot;, i.e. school, attributes for
  # each possible answer to quest, i.e. Agree and Disagree, and N size for each
  # break based on how many people responded to that question, not the survey as
  # a whole, i.e. 

  # Break each component of the vector rows into separate single-element vectors
  # for convenience and clarity.
  quest &amp;lt;- as.character(rows[1])
  survey &amp;lt;- as.character(rows[2])
  year  &amp;lt;- as.character(rows[3])
  break &amp;lt;- as.character(rows[4])
  data &amp;lt;- get(paste(level,year,sep=&#39;&#39;))
  # Data is an alias for the data.frame described by level and year.
  # This alias reduces the number of &amp;quot;get&amp;quot; calls to speed up code and increase
  # clarity.
  results &amp;lt;- with(data,
                  dcast(data.frame(prop.table(table(data[[break]],
                                                    data[[quest]]),
                                              1))
                        ,Var1~Var2,value.var=&#39;Freq&#39;))
  # Produces a table with the proportions for each response in wide format.
  n &amp;lt;- data.frame(Var1=rle(sort(
    subset(data, 
           is.na(data[[quest]])==F &amp;amp; is.na(data[[break]])==F)[[break]]))$values,
                  n=rle(sort(
                    subset(data,
                           is.na(data[[quest]])==F &amp;amp;
                             is.na(data[[break]])==F)[[break]]))$lengths)
  # Generates a data frame with each break element and the &amp;quot;length&amp;quot; of that break
  # element. rle counts the occurrences of a value in a vector in order. So first
  # you sort the vector so all common break values are adjacent then you use rle
  # to count their uninterupted appearance. The result is an rle object with 
  # two components: [[values]] which represent the values in the original, sorted
  # vector and [[length]] which is the count of their uninterupted repeated
  # appearance in that vector.
  results &amp;lt;- merge(results, n, by=&#39;Var1&#39;)
  # Combines N values with the results table.

  state &amp;lt;- data.frame(t(c(Var1=&#39;Rhode Island&#39;, 
                          prop.table(table(data[[quest]])),
                          n=dim(subset(data,is.na(data[[quest]])==F))[1])))
  names(state) &amp;lt;- names(results)
  for(i in 2:dim(state)[2]){
    state[,i] &amp;lt;- as.numeric(as.character(state[,i]))
  }
  # Because the state data.frame has only one row, R coerces to type factor.
  # If I rbind() a factor to a numeric attribute, R will coerce them both to
  # characters and refuses to convert back to type numeric.
  results &amp;lt;- rbind(results, state)
  results
}   
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
